<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>ü§ñ Robot Control Dashboard</title>
		<style>
			body {
				font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
				max-width: 1200px;
				margin: 20px auto;
				padding: 20px;
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				color: #333;
				min-height: 100vh;
			}
			.container {
				background: rgba(255, 255, 255, 0.95);
				padding: 30px;
				border-radius: 15px;
				box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
				backdrop-filter: blur(10px);
				margin-bottom: 20px;
			}
			h1 {
				text-align: center;
				color: #2c3e50;
				margin-bottom: 30px;
				font-size: 2.5em;
				text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
			}
			.dashboard-grid {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
				gap: 20px;
				margin-top: 20px;
			}
			.control-group {
				margin: 20px 0;
				padding: 20px;
				border: 1px solid #ddd;
				border-radius: 8px;
			}
			.control-group h3 {
				margin-top: 0;
				color: #555;
			}
			button {
				background: #4caf50;
				color: white;
				border: none;
				padding: 12px 20px;
				border-radius: 5px;
				cursor: pointer;
				font-size: 16px;
				margin: 5px;
			}
			button:hover {
				background: #45a049;
			}
			button:disabled {
				background: #ccc;
				cursor: not-allowed;
			}
			.record-btn.recording {
				background: #f44336;
				animation: pulse 1s infinite;
			}
			@keyframes pulse {
				0% {
					opacity: 1;
				}
				50% {
					opacity: 0.7;
				}
				100% {
					opacity: 1;
				}
			}
			.status {
				padding: 10px;
				margin: 10px 0;
				border-radius: 5px;
				font-weight: bold;
			}
			.success {
				background: #d4edda;
				color: #155724;
			}
			.error {
				background: #f8d7da;
				color: #721c24;
			}
			.info {
				background: #d1ecf1;
				color: #0c5460;
			}
			input[type="text"] {
				width: 100%;
				padding: 10px;
				border: 1px solid #ddd;
				border-radius: 5px;
				margin: 5px 0;
				font-size: 14px;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h1>üé§ Robot Audio Chat Test</h1>

			<div class="control-group">
				<h3>üéôÔ∏è One-Way Audio Chat (Laptop Mic ‚Üí Pi Speaker)</h3>
				<button id="recordBtn" class="record-btn">üé§ Start Recording</button>
				<button id="playBtn" disabled>‚ñ∂Ô∏è Play Recording</button>
				<button id="sendBtn" disabled>üì° Send to Pi Speaker</button>
				<div id="recordingStatus"></div>
			</div>

			<div class="control-group">
				<h3>üí¨ Text-to-Speech Test</h3>
				<input
					type="text"
					id="textInput"
					placeholder="Enter text to speak through Pi..."
					value="‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§Æ‡•à‡§Ç ‡§≤‡•à‡§™‡§ü‡•â‡§™ ‡§∏‡•á ‡§¨‡•ã‡§≤ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Ç"
				/>
				<br />
				<button onclick="sendText()">üîä Speak on Pi</button>
			</div>

			<div class="control-group">
				<h3>‚è∞ Reminder Test</h3>
				<input
					type="text"
					id="reminderText"
					placeholder="Reminder message..."
					value="‡§ü‡•á‡§∏‡•ç‡§ü ‡§∞‡§ø‡§Æ‡§æ‡§á‡§Ç‡§°‡§∞"
				/>
				<input
					type="number"
					id="reminderDelay"
					placeholder="Delay in seconds"
					value="10"
				/>
				<br />
				<button onclick="addReminder()">‚è∞ Add Reminder</button>
				<button onclick="listReminders()">üìã List Reminders</button>
			</div>

			<div id="status"></div>
		</div>

		<script>
			let mediaRecorder;
			let recordedChunks = [];
			let recordedBlob;

			const recordBtn = document.getElementById("recordBtn");
			const playBtn = document.getElementById("playBtn");
			const sendBtn = document.getElementById("sendBtn");
			const status = document.getElementById("status");
			const recordingStatus = document.getElementById("recordingStatus");

			// Initialize audio recording
			recordBtn.addEventListener("click", toggleRecording);
			playBtn.addEventListener("click", playRecording);
			sendBtn.addEventListener("click", sendAudioToPi);

			async function toggleRecording() {
				if (!mediaRecorder || mediaRecorder.state === "inactive") {
					startRecording();
				} else {
					stopRecording();
				}
			}

			async function startRecording() {
				try {
					const stream = await navigator.mediaDevices.getUserMedia({
						audio: {
							echoCancellation: true,
							noiseSuppression: true,
							autoGainControl: true,
							sampleRate: 16000, // Lower sample rate for Pi compatibility
							channelCount: 1,   // Mono audio
						},
					});

					recordedChunks = [];
					
					// Choose the best format for Pi compatibility
					let options = {};
					if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
						options = {
							mimeType: 'audio/webm;codecs=opus',
							audioBitsPerSecond: 48000  // Good quality for speech
						};
					} else if (MediaRecorder.isTypeSupported('audio/mp4')) {
						options = {
							mimeType: 'audio/mp4',
							audioBitsPerSecond: 64000
						};
					} else if (MediaRecorder.isTypeSupported('audio/webm')) {
						options = {
							mimeType: 'audio/webm',
							audioBitsPerSecond: 48000
						};
					}
					
					mediaRecorder = new MediaRecorder(stream, options);
					console.log('üé§ Recording with format:', mediaRecorder.mimeType, 'bitrate:', options.audioBitsPerSecond);

					mediaRecorder.ondataavailable = (e) => {
						if (e.data.size > 0) recordedChunks.push(e.data);
					};

					mediaRecorder.onstop = () => {
						// Use the actual recorded format, not fake WAV
						const actualMimeType = mediaRecorder.mimeType || 'audio/webm';
						recordedBlob = new Blob(recordedChunks, { type: actualMimeType });
						
						playBtn.disabled = false;
						sendBtn.disabled = false;
						recordingStatus.innerHTML =
							`<div class="info">‚úÖ Recording complete! Format: ${actualMimeType.split(';')[0]}. You can now play or send to Pi.</div>`;
					};

					mediaRecorder.start(1000); // Record in 1-second chunks for better quality
					recordBtn.textContent = "‚èπÔ∏è Stop Recording";
					recordBtn.classList.add("recording");
					recordingStatus.innerHTML =
						'<div class="info">üî¥ Recording... Click stop when done.</div>';
					playBtn.disabled = true;
					sendBtn.disabled = true;
				} catch (err) {
					showStatus("‚ùå Error accessing microphone: " + err.message, "error");
				}
			}

			function stopRecording() {
				if (mediaRecorder && mediaRecorder.state === "recording") {
					mediaRecorder.stop();
					mediaRecorder.stream.getTracks().forEach((track) => track.stop());
					recordBtn.textContent = "üé§ Start Recording";
					recordBtn.classList.remove("recording");
				}
			}

			function playRecording() {
				if (recordedBlob) {
					const audio = new Audio(URL.createObjectURL(recordedBlob));
					audio.play();
					showStatus("‚ñ∂Ô∏è Playing recorded audio locally...", "info");
				}
			}

			async function sendAudioToPi() {
				if (!recordedBlob) {
					showStatus("‚ùå No recording to send", "error");
					return;
				}

				const formData = new FormData();
				
				// Use proper filename based on actual format
				let filename = "mic_audio.webm";
				if (recordedBlob.type.includes('mp4')) {
					filename = "mic_audio.mp4";
				} else if (recordedBlob.type.includes('wav')) {
					filename = "mic_audio.wav";
				} else if (recordedBlob.type.includes('ogg')) {
					filename = "mic_audio.ogg";
				}
				
				formData.append("file", recordedBlob, filename);
				console.log(`Sending audio file: ${filename}, type: ${recordedBlob.type}, size: ${recordedBlob.size} bytes`);

				try {
					showStatus("üì° Sending audio to Pi speaker...", "info");

					const response = await fetch(
						"http://localhost:5050/api/assistant/audio-chat",
						{
							method: "POST",
							body: formData,
						}
					);

					let result;
					const responseText = await response.text();

					try {
						result = JSON.parse(responseText);
					} catch (parseErr) {
						showStatus(
							`‚ùå Server returned non-JSON response (${
								response.status
							}): ${responseText.substring(0, 200)}`,
							"error"
						);
						return;
					}

					if (response.ok) {
						showStatus(
							`‚úÖ Audio sent successfully! Playing through Pi speaker. (${result.file_size} bytes)`,
							"success"
						);
					} else {
						showStatus("‚ùå Failed to send audio: " + result.message, "error");
					}
				} catch (err) {
					showStatus("‚ùå Network error: " + err.message, "error");
				}
			}

			async function sendText() {
				const text = document.getElementById("textInput").value.trim();
				if (!text) {
					showStatus("‚ùå Please enter text to speak", "error");
					return;
				}

				try {
					showStatus("üì° Sending text to Pi speaker...", "info");

					const response = await fetch(
						"http://localhost:5050/api/assistant/message",
						{
							method: "POST",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({ text: text, speak: true }),
						}
					);

					let result;
					const responseText = await response.text();

					try {
						result = JSON.parse(responseText);
					} catch (parseErr) {
						showStatus(
							`‚ùå Server returned non-JSON response (${
								response.status
							}): ${responseText.substring(0, 200)}`,
							"error"
						);
						return;
					}

					if (response.ok) {
						showStatus(
							"‚úÖ Text sent successfully! Speaking through Pi.",
							"success"
						);
					} else {
						showStatus("‚ùå Failed to send text: " + result.message, "error");
					}
				} catch (err) {
					showStatus("‚ùå Network error: " + err.message, "error");
				}
			}

			async function addReminder() {
				const text = document.getElementById("reminderText").value.trim();
				const delay =
					parseInt(document.getElementById("reminderDelay").value) || 10;

				if (!text) {
					showStatus("‚ùå Please enter reminder text", "error");
					return;
				}

				try {
					showStatus(
						`‚è∞ Adding reminder for ${delay} seconds from now...`,
						"info"
					);

					const response = await fetch(
						"http://localhost:5050/api/assistant/reminders",
						{
							method: "POST",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({
								message: text,
								delay_seconds: delay,
							}),
						}
					);

					let result;
					const responseText = await response.text();

					try {
						result = JSON.parse(responseText);
					} catch (parseErr) {
						showStatus(
							`‚ùå Server returned non-JSON response (${
								response.status
							}): ${responseText.substring(0, 200)}`,
							"error"
						);
						return;
					}

					if (response.ok) {
						showStatus(
							`‚úÖ Reminder added! Will trigger in ${delay} seconds.`,
							"success"
						);
					} else {
						showStatus("‚ùå Failed to add reminder: " + result.message, "error");
					}
				} catch (err) {
					showStatus("‚ùå Network error: " + err.message, "error");
				}
			}

			async function listReminders() {
				try {
					const response = await fetch(
						"http://localhost:5050/api/assistant/reminders"
					);
					const result = await response.json();

					if (response.ok && result.reminders) {
						const count = result.reminders.length;
						showStatus(
							`üìã Found ${count} active reminders. Check console for details.`,
							"info"
						);
						console.log("Active reminders:", result.reminders);
					} else {
						showStatus(
							"‚ùå Failed to get reminders: " +
								(result.message || "Unknown error"),
							"error"
						);
					}
				} catch (err) {
					showStatus("‚ùå Network error: " + err.message, "error");
				}
			}

			function showStatus(message, type) {
				status.innerHTML = `<div class="${type}">${message}</div>`;
				setTimeout(() => (status.innerHTML = ""), 5000);
			}

			// Auto-check status on load
			window.addEventListener("load", async () => {
				try {
					const response = await fetch("http://localhost:5050/api/status");
					const result = await response.json();

					if (response.ok) {
						showStatus(
							`ü§ñ Connected to robot supervisor. Pi: ${
								result.pi_connected ? "‚úÖ" : "‚ùå"
							}`,
							"success"
						);
					} else {
						showStatus(
							"‚ö†Ô∏è Robot supervisor not running. Start windows_robot_supervisor.py first.",
							"error"
						);
					}
				} catch (err) {
					showStatus(
						"‚ö†Ô∏è Cannot connect to robot supervisor. Start windows_robot_supervisor.py first.",
						"error"
					);
				}
			});
		</script>
	</body>
</html>
